import { Component, h, Prop, State, Watch, Event, EventEmitter } from '@stencil/core';

// üßë‚Äçüíª Declare OdinPay at the module level for type safety if you create a .d.ts file for it
//    or use 'any' for now.
declare const OdinPay: any;

// Define payload interfaces for events (can be moved/shared later)
export interface OdinPaySubmitPayload {
  paymentMethodId: string;
  billingInformation?: OdinPayBillingInformation;
}

export interface OdinPayFieldError {
  field: string; // The name of the field (e.g., "card", "postalCode", "name") or a generic key like "0"
  message: string; // The specific error message for this field
}

export interface OdinPayErrorPayload {
  code: string; // e.g., 'VALIDATION_ERROR', 'API_ERROR', 'GENERAL_ERROR', 'SDK_LOAD_ERROR', etc.
  message: string; // A general, human-readable error message, possibly a summary.
  fieldErrors?: OdinPayFieldError[]; // Optional: For field-specific validation errors
  httpStatusCode?: number; // Optional: For API errors
  rawError?: any; // Optional: For debugging, could include the original result.message
}

// Configuration for enabling and customizing fields
export type BillingFieldsConfig = {
  // Optional fields can be true (enable with defaults) or customized
  [FieldName in OptionalBillingFieldName]?: boolean | FieldCustomization;
} & {
  // Mandatory fields like postalCode can only be customized (they are always implicitly 'true')
  postalCode?: FieldCustomization;
  cardInformation?: FieldCustomization;
};

// Represents customization for a single field
export interface FieldCustomization {
  label?: string;
  placeholder?: string;
}

// Define the names of fields that can be optionally shown/customized
type OptionalBillingFieldName = 'name' | 'addressLine1' | 'addressLine2' | 'city' | 'state' | 'country' | 'emailAddress' | 'phoneNumber';

// Nested address object structure
export interface OdinPayBillingAddress {
  addressLine1?: string; // Present if configured, "" if empty
  addressLine2?: string; // Present if configured, "" if empty
  city?: string; // Present if configured, "" if empty
  state?: string; // Present if configured, "" if empty
  postalCode?: string; // Present if configured, "" if empty
  country?: string; // Present if configured, "" if empty
}

// Top-level billing information structure
export interface OdinPayBillingInformation {
  name?: string; // Present if configured, "" if empty
  emailAddress?: string; // Present if configured, "" if empty
  phoneNumber?: string; // Present if configured, "" if empty
  address?: OdinPayBillingAddress; // Present if ANY address field was configured
}

// Define default labels and placeholders
const DEFAULT_FIELD_TEXT: { [key: string]: FieldCustomization } = {
  cardInformation: { label: 'Card Information', placeholder: undefined },
  name: { label: 'Name on Card', placeholder: 'Full Name' },
  postalCode: { label: 'Postal Code', placeholder: 'Postal Code' }, // Placeholder might vary by country in OdinPay.js itself
  addressLine1: { label: 'Address Line 1', placeholder: 'Street Address' },
  addressLine2: { label: 'Address Line 2 (Optional)', placeholder: 'Apartment, suite, etc.' },
  city: { label: 'City', placeholder: 'City' },
  state: { label: 'State / Province', placeholder: 'State / Province' }, // Label accommodates US/CA
  country: { label: 'Country', placeholder: 'Country' }, // Placeholder might be less useful if OdinPay renders a dropdown
  emailAddress: { label: 'Email Address', placeholder: 'you@example.com' },
  phoneNumber: { label: 'Phone Number', placeholder: '(123) 456-7890' },
};

@Component({
  tag: 'exerp-odin-cc-form',
  styleUrl: 'exerp-odin-cc-form.css',
  shadow: false,
})
export class ExerpOdinCcForm {
  /**
   * The short-lived public token obtained from the ODIN backend,
   * required to initialize the OdinPay.js library.
   * Passed down from the facade.
   */
  @Prop() odinPublicToken?: string;

  /**
   * Indicates if the payment method token generated by OdinPay.js
   * should be treated as single-use (`true`) or intended for saving (`false`).
   * Passed down from the facade. Defaults to `true`.
   */
  @Prop() isSingleUse: boolean = true;

  /**
   * The country code ('US' or 'CA') for which the payment form should be configured.
   * This is mandatory and passed to OdinPay.js.
   */
  @Prop() countryCode!: 'US' | 'CA'; // Making it mandatory and specific

  /**
   * Optional configuration to enable and customize billing fields.
   * This object determines which optional billing fields are rendered and allows
   * overriding their default labels and placeholders.
   *
   * - For optional fields (e.g., `name`, `addressLine1`):
   *   - `true`: Enables the field with default label and placeholder.
   *   - `FieldCustomization` object (e.g., `{ label?: 'Custom Label', placeholder?: 'Custom Hint' }`):
   *     Enables the field and applies the specified customizations.
   *   - If a field key is omitted, the field is not rendered.
   *
   * - For fields that are always structurally part of the form but can be customized
   *   (e.g., `postalCode` label/placeholder, `cardInformation` label):
   *   - Provide a `FieldCustomization` object to override default texts.
   *
   * Example:
   * `{
   *   name: true, // Enable 'Name on Card' with defaults
   *   addressLine1: { label: 'Street Address Line 1' }, // Custom label for address
   *   city: { placeholder: 'Enter your city here' }, // Custom placeholder for city
   *   postalCode: { label: 'Zip/Postal' } // Custom label for postal code
   * }`
   *
   * Refer to the `BillingFieldsConfig` and `FieldCustomization` type definitions
   * within this file for the exact structure and available field names.
   */
  @Prop() billingFieldsConfig?: BillingFieldsConfig;

  /**
   * Fired when OdinPay.js successfully returns a payment method token
   * after the user submits the form. The event detail contains the
   * `paymentMethodId` and, if applicable, the `billingInformation`
   * collected from the form.
   */
  @Event() odinSubmitInternal!: EventEmitter<OdinPaySubmitPayload>;

  /**
   * Fired when OdinPay.js returns an error during submission
   * or if an internal setup error occurs. Contains the error message.
   */
  @Event() odinErrorInternal!: EventEmitter<OdinPayErrorPayload>;

  @State() private odinPayInstance: any = null;
  @State() private scriptLoaded: boolean = false;
  @State() private initializationError: string | null = null;
  @State() private isLoading: boolean = false;
  @State() private odinFormRenderedBySDK: boolean = false;

  private componentId = `exerp-odin-cc-form-${Math.random().toString(36).substring(2, 9)}`;
  private cardInfoId = `${this.componentId}-card-info`;
  private nameOnCardId = `${this.componentId}-name-on-card`;
  private postalCodeId = `${this.componentId}-postal-code`;
  private odinSubmitButtonId = `${this.componentId}-odin-submit-button`;
  private visibleSubmitButtonId = `${this.componentId}-visible-submit-button`;

  private addressLine1Id = `${this.componentId}-address-line1`;
  private addressLine2Id = `${this.componentId}-address-line2`;
  private cityId = `${this.componentId}-city`;
  private stateId = `${this.componentId}-state`;
  private countryId = `${this.componentId}-country`;
  private emailAddressId = `${this.componentId}-email-address`;
  private phoneNumberId = `${this.componentId}-phone-number`;

  /** Helper to check if a field should be rendered */
  private isFieldEnabled(fieldName: keyof BillingFieldsConfig): boolean {
    return !!this.billingFieldsConfig?.[fieldName];
  }

  /** Helper to get the customization object for a field */
  private getFieldCustomization(fieldName: keyof BillingFieldsConfig): FieldCustomization | undefined {
    const configValue = this.billingFieldsConfig?.[fieldName];
    return typeof configValue === 'object' ? configValue : undefined;
  }

  /** Helper to get the label for a field */
  private getLabel(fieldName: keyof BillingFieldsConfig): string {
    const customLabel = this.getFieldCustomization(fieldName)?.label;
    return customLabel ?? DEFAULT_FIELD_TEXT[fieldName]?.label ?? fieldName; // Fallback to fieldName if no default
  }

  /** Helper to get the placeholder for a field */
  private getPlaceholder(fieldName: keyof BillingFieldsConfig): string | undefined {
    const customPlaceholder = this.getFieldCustomization(fieldName)?.placeholder;
    // Return custom placeholder, default placeholder, or undefined if neither exists
    return customPlaceholder ?? DEFAULT_FIELD_TEXT[fieldName]?.placeholder ?? undefined;
  }

  private loadScript(url: string, id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      if (document.getElementById(id)) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = url;
      script.id = id;
      script.async = true;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
      document.head.appendChild(script);
    });
  }

  async componentDidLoad() {
    console.log('[Core Component] componentDidLoad - odinPublicToken:', this.odinPublicToken, 'countryCode:', this.countryCode);
    // Check for countryCode before initializing
    if (this.odinPublicToken && this.countryCode) {
      await this.initializeOdinPayAndForm();
    } else if (!this.countryCode) {
      const errorMsg = '[Core Component] countryCode prop is missing. Cannot initialize OdinPay.';
      console.error(errorMsg);
      this.initializationError = errorMsg;
      this.odinErrorInternal.emit({ message: errorMsg, code: 'INIT_NO_COUNTRY_CODE' });
      this.isLoading = false;
    }
  }

  @Watch('odinPublicToken')
  async watchOdinPublicToken(newValue: string, oldValue: string) {
    if (newValue && newValue !== oldValue) {
      console.log('[Core Component] odinPublicToken changed, re-initializing OdinPay. Current countryCode:', this.countryCode);
      // Check for countryCode before re-initializing
      if (this.countryCode) {
        await this.initializeOdinPayAndForm();
      } else {
        const errorMsg = '[Core Component] countryCode prop is missing on token change. Cannot re-initialize OdinPay.';
        console.error(errorMsg);
        // Optionally emit an error or handle as appropriate
        this.initializationError = errorMsg;
        this.odinErrorInternal.emit({ message: errorMsg, code: 'INIT_NO_COUNTRY_CODE_ON_UPDATE' });
        this.isLoading = false;
      }
    }
  }

  @Watch('countryCode')
  async watchCountryCode(newValue: string, oldValue: string) {
    if (newValue && newValue !== oldValue && this.odinPublicToken) {
      console.log('[Core Component] countryCode changed, re-initializing OdinPay. New value:', newValue);
      await this.initializeOdinPayAndForm();
    } else if (!newValue && this.odinPublicToken) {
      const errorMsg = '[Core Component] countryCode prop was unset. Cannot re-initialize OdinPay.';
      console.error(errorMsg);
      this.initializationError = errorMsg;
      this.odinErrorInternal.emit({ message: errorMsg, code: 'INIT_NO_COUNTRY_CODE_ON_UPDATE' });
      this.isLoading = false;
    }
  }

  private async initializeOdinPayAndForm() {
    this.isLoading = true;
    this.initializationError = null;
    this.odinFormRenderedBySDK = false;

    // Early exit if countryCode is missing (though props should ensure it, this is defensive)
    if (!this.countryCode) {
      const errorMsg = '[Core Component] Internal Error: countryCode is missing in initializeOdinPayAndForm.';
      console.error(errorMsg);
      this.initializationError = errorMsg;
      this.odinErrorInternal.emit({ message: errorMsg, code: 'INIT_NO_COUNTRY_CODE_INTERNAL' });
      this.isLoading = false;
      return;
    }

    try {
      if (!this.scriptLoaded) {
        await this.loadScript('https://js.odinpay.net', 'odin-pay-sdk');
        this.scriptLoaded = true;
        console.log('[Core Component] OdinPay.js script loaded.');
      }

      if (typeof OdinPay === 'undefined') {
        this.initializationError = 'OdinPay SDK is not available even after script load.';
        console.error(this.initializationError);
        this.odinErrorInternal.emit({ message: this.initializationError, code: 'SDK_LOAD_ERROR' });
        this.isLoading = false;
        return;
      }

      // Basic theme from CodePen example, can be made configurable via prop later
      const baseTheme = {
        // Define our base theme structure
        input: {
          base: {
            fontFamily: '-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans',
            fontSize: '16px',
          },
          invalid: {
            color: 'red',
            borderColor: 'red',
          },
        },
      };

      // Construct the options object with 'country' and a nested 'theme'
      const odinPayOptions = {
        country: this.countryCode,
        theme: baseTheme,
      };
      console.log(`[Core Component] About to call OdinPay(). Token:`, this.odinPublicToken, `Options:`, JSON.stringify(odinPayOptions));

      try {
        this.odinPayInstance = OdinPay(this.odinPublicToken, odinPayOptions);
      } catch (odinConstructorError: any) {
        console.error('[Core Component] Error DIRECTLY from OdinPay() constructor:', odinConstructorError);
        // Re-throw to be caught by the outer catch block which handles emitting the event
        this.odinPayInstance = null;
        throw odinConstructorError;
      }

      console.log('[Core Component] OdinPay initialized with instance:', this.odinPayInstance);
      this.initializationError = null;

      // Call the method to create the form
      this.renderOdinForm();
    } catch (error: any) {
      // We're keeping `error: any` for now, can be typed as `Error`
      console.error('[Core Component] RAW Error object during OdinPay initialization:', error);
      const errorMessage = error?.message || 'Failed to initialize OdinPay.';
      console.error('[Core Component] Error initializing OdinPay (processed message):', errorMessage);
      this.initializationError = errorMessage; // This state is used for display within the component itself

      let specificErrorCode = 'INITIALIZATION_ERROR'; // Default/general initialization error code

      // Try to map known OdinPay.js initialization error messages to more specific codes
      if (errorMessage === 'No key provided') {
        specificErrorCode = 'INIT_NO_KEY_PROVIDED';
      } else if (errorMessage === 'Badly formatted key') {
        specificErrorCode = 'INIT_BADLY_FORMATTED_KEY';
      } else if (errorMessage === 'Invalid Key') {
        // When key JSON structure is wrong
        specificErrorCode = 'INIT_INVALID_KEY_STRUCTURE';
      } else if (errorMessage.startsWith('Unsupported country')) {
        specificErrorCode = 'INIT_UNSUPPORTED_COUNTRY';
      } else if (
        errorMessage.includes('BasisTheoryElements') ||
        errorMessage.includes('Elements script') || // Error from BT script loader
        errorMessage.includes('API key is required') // BT API key missing from OdinPay key
      ) {
        specificErrorCode = 'INIT_BT_SDK_FAILURE'; // General code for BasisTheory SDK related issues
      }
      // Add more specific checks if other distinct initialization errors are identified

      const errorPayload: OdinPayErrorPayload = {
        code: specificErrorCode,
        message: errorMessage,
        // fieldErrors and httpStatusCode are typically not applicable for these synchronous init errors
        rawError: error, // Also good to include the raw error in the emitted payload
      };
      this.odinErrorInternal.emit(errorPayload);

      this.odinPayInstance = null; // Ensure instance is null
      this.isLoading = false; // Ensure loading is stopped
    }
  }

  // Method to create the card form using OdinPay.js
  private renderOdinForm() {
    if (!this.odinPayInstance) {
      console.warn('[Core Component] OdinPay instance not available to create form.');
      if (!this.initializationError) {
        // Defensive set if somehow missed
        this.initializationError = 'OdinPay instance is null, cannot render form.';
        this.odinErrorInternal.emit({ message: this.initializationError, code: 'INSTANCE_NULL' });
      }
      this.odinFormRenderedBySDK = false;
      this.isLoading = false;
      return;
    }

    console.log(`[Core Component] Attempting to create card form. isSingleUse: ${this.isSingleUse}`);

    // --- Start Dynamically Building Fields Config ---
    const odinPayFields: any = {
      // Base required fields for OdinPay card form
      cardInformation: {
        selector: this.cardInfoId,
        // ariaLabel: this.getAriaLabel('cardInformation'), // Future: Add Aria Label customization
      },
      postalCode: {
        selector: this.postalCodeId,
        placeholder: this.getPlaceholder('postalCode'), // Use helper for placeholder
        // ariaLabel: this.getAriaLabel('postalCode'), // Future
      },
    };

    // Define the mapping from our config keys to the OdinPay field keys and their container IDs
    const optionalFieldMapping: { [key in OptionalBillingFieldName]: string } = {
      name: this.nameOnCardId,
      addressLine1: this.addressLine1Id,
      addressLine2: this.addressLine2Id,
      city: this.cityId,
      state: this.stateId,
      country: this.countryId,
      emailAddress: this.emailAddressId,
      phoneNumber: this.phoneNumberId,
    };

    // Iterate over the mapping to add configured optional fields
    for (const fieldName in optionalFieldMapping) {
      // Check if the field is enabled in our component's config
      if (this.isFieldEnabled(fieldName as OptionalBillingFieldName)) {
        const fieldId = optionalFieldMapping[fieldName as OptionalBillingFieldName];
        // Add the field config to the object OdinPay expects
        odinPayFields[fieldName] = {
          selector: fieldId,
          placeholder: this.getPlaceholder(fieldName as OptionalBillingFieldName), // Get custom/default placeholder
          // ariaLabel: this.getAriaLabel(fieldName), // Future
        };
      }
    }
    // --- End Dynamically Building Fields Config ---

    console.log('[Core Component] Final fields object being passed to OdinPay.createCardForm:', JSON.stringify(odinPayFields, null, 2));

    try {
      this.odinPayInstance.createCardForm({
        isSingleUse: this.isSingleUse,
        submitButton: {
          selector: this.odinSubmitButtonId,
          callback: (result: any) => {
            // Note: result is still 'any' as it comes from external lib
            console.log('[Core Component] OdinPay submit callback RAW result:', JSON.stringify(result, null, 2));

            if (result && result.success === true && result.paymentMethod && result.paymentMethod.id) {
              console.log('[Core Component] Success! PaymentMethodID:', result.paymentMethod.id);

              // --- Extract billingInformation ---
              let billingInfo: OdinPayBillingInformation | undefined = undefined;
              if (result.paymentMethod.billingInformation) {
                // We assume OdinPay.js returns data matching our OdinPayBillingInformation interface
                // No complex mapping needed here if the structure report was accurate.
                billingInfo = result.paymentMethod.billingInformation as OdinPayBillingInformation;
                console.log('[Core Component] Extracted billingInformation:', JSON.stringify(billingInfo, null, 2));
              } else {
                console.log('[Core Component] No billingInformation found in OdinPay result.paymentMethod.');
              }
              // --- End Extracting billingInformation ---

              // Emit success event
              this.odinSubmitInternal.emit({
                paymentMethodId: result.paymentMethod.id,
                billingInformation: billingInfo,
              });
            } else if (result && result.success === false) {
              // Handle error based on result.message
              console.error('[Core Component] Error from OdinPay callback. Raw result.message:', result.message);
              const parsedErrorPayload = this.parseOdinPayError(result);
              this.odinErrorInternal.emit(parsedErrorPayload);
            } else {
              // Handle unexpected structure
              console.warn('[Core Component] OdinPay callback with unexpected result structure:', result);
              this.odinErrorInternal.emit({
                message: 'Received an unexpected result structure from OdinPay.',
                code: 'UNEXPECTED_CALLBACK_STRUCTURE',
              });
            }
            this.isLoading = false; // Set loading false after callback processing
          },
        },
        fields: odinPayFields,
      });
      console.log('[Core Component] OdinPay createCardForm called successfully.');
      this.initializationError = null;
      this.odinFormRenderedBySDK = true;
      this.isLoading = false; // Set loading false after createCardForm call succeeds
    } catch (error) {
      // FIXME -- Expect the actual Error type here.
      console.error('[Core Component] Error calling createCardForm:', error);
      this.initializationError = (error as any)?.message || 'Failed to create OdinPay card form.';
      this.odinErrorInternal.emit({ message: this.initializationError!, code: 'CREATE_FORM_ERROR' });
      this.odinFormRenderedBySDK = false;
      this.isLoading = false;
    }
  }

  private handleVisibleSubmitClick = () => {
    console.log('[Core Component] Visible submit button clicked.');

    // --- Guard against submission if not properly initialized/rendered ---
    if (this.isLoading || !this.odinPayInstance || !this.odinFormRenderedBySDK || this.initializationError) {
      console.warn(
        '[Core Component] Submission prevented. isLoading:',
        this.isLoading,
        'hasInstance:',
        !!this.odinPayInstance,
        'formRendered:',
        this.odinFormRenderedBySDK,
        'initError:',
        this.initializationError,
      );
      // Optionally, re-emit the initializationError if it exists, or a new error
      if (this.initializationError) {
        this.odinErrorInternal.emit({ message: `Cannot submit: ${this.initializationError}`, code: 'SUBMIT_WHILE_INIT_ERROR' });
      } else if (!this.odinPayInstance || !this.odinFormRenderedBySDK) {
        this.odinErrorInternal.emit({ message: 'Cannot submit: Form not ready.', code: 'FORM_NOT_READY' });
      }
      return;
    }

    // Set loading state
    this.isLoading = true;

    // Find the hidden button and click it programmatically
    const odinButton = document.getElementById(this.odinSubmitButtonId);
    if (odinButton) {
      console.log('[Core Component] Programmatically clicking hidden Odin button.');
      odinButton.click();
      // Note: isLoading will be set to false inside the OdinPay callback
    } else {
      console.error('[Core Component] Hidden Odin submit button not found!');
      this.odinErrorInternal.emit({ message: 'Internal error: Submit button not found.', code: 'INTERNAL_ERROR' });
      this.isLoading = false; // Stop loading if we can't proceed
    }
  };

  private parseOdinPayError(odinResult: any): OdinPayErrorPayload {
    let code = 'ODIN_CALLBACK_ERROR'; // Default code
    let generalMessage = 'An error occurred during payment processing.';
    const fieldErrors: OdinPayFieldError[] = [];
    let httpStatusCode: number | undefined;

    if (typeof odinResult.message === 'string') {
      generalMessage = odinResult.message;
      // Try to extract HTTP status code
      const httpMatch = odinResult.message.match(/Error: HTTP error. Status: (\d+)/);
      if (httpMatch && httpMatch[1]) {
        httpStatusCode = parseInt(httpMatch[1], 10);
        code = httpStatusCode >= 500 ? 'API_SERVER_ERROR' : 'API_CLIENT_ERROR';
        if (httpStatusCode === 401) code = 'API_AUTH_ERROR';
      } else {
        code = 'GENERAL_PAYMENT_ERROR';
      }
    } else if (Array.isArray(odinResult.message)) {
      // For now, join array messages into one general message
      // We can enhance this later if specific array messages need distinct handling
      generalMessage = odinResult.message.join('; ');
      code = 'VALIDATION_ERROR_GENERAL';
      // We could also populate fieldErrors if we can parse these strings further
      odinResult.message.forEach((msg: string, index: number) => {
        fieldErrors.push({ field: `general[${index}]`, message: msg });
      });
    } else if (typeof odinResult.message === 'object' && odinResult.message !== null) {
      generalMessage = 'Validation failed. Please check the fields below.'; // More generic message
      code = 'VALIDATION_ERROR_FIELDS';
      for (const fieldKey in odinResult.message) {
        if (Object.prototype.hasOwnProperty.call(odinResult.message, fieldKey)) {
          fieldErrors.push({
            field: fieldKey,
            message: odinResult.message[fieldKey] as string, // Assuming messages are strings
          });
        }
      }
      if (fieldErrors.length === 1 && fieldErrors[0].field.match(/^\d+$/)) {
        // If it's an object but has only numeric keys (like "0"), it's more like a general validation message
        generalMessage = fieldErrors[0].message;
      }
    } else {
      generalMessage = 'An unknown error occurred.';
      code = 'UNKNOWN_ERROR';
    }

    const payload: OdinPayErrorPayload = {
      code,
      message: generalMessage,
    };
    if (fieldErrors.length > 0) {
      payload.fieldErrors = fieldErrors;
    }
    if (httpStatusCode) {
      payload.httpStatusCode = httpStatusCode;
    }
    payload.rawError = odinResult.message;

    return payload;
  }

  render() {
    const isButtonDisabled = this.isLoading || !this.odinFormRenderedBySDK || !!this.initializationError;

    // üßë‚Äçüíª Define the order of fields for rendering
    const fieldRenderOrder: (keyof BillingFieldsConfig)[] = [
      'name',
      'addressLine1',
      'addressLine2',
      'city',
      'state',
      'postalCode', // Keep postal code near address fields
      'country',
      'emailAddress',
      'phoneNumber',
    ];

    return (
      <div class="exerp-odin-dropin-container">
        {/* Initialization Error Display */}
        {this.initializationError && (
          <div class="odin-error-message-container" role="alert">
            Initialization Error: {this.initializationError}
          </div>
        )}

        {/* Card Information */}
        <div class="odin-field-container">
          <label htmlFor={this.cardInfoId}>{this.getLabel('cardInformation')}</label>
          <div id={this.cardInfoId} class="odin-input"></div>
        </div>

        {/* Dynamically Rendered Billing Fields */}
        {fieldRenderOrder.map(fieldName => {
          // Always render the container for postalCode as OdinPay needs it, but respect custom label/placeholder
          if (fieldName === 'postalCode') {
            return (
              <div class="odin-field-container" key={fieldName}>
                <label htmlFor={this.postalCodeId}>{this.getLabel(fieldName)}</label>
                <div id={this.postalCodeId} class="odin-input"></div>
              </div>
            );
          }
          // For other fields, check if enabled in config
          else if (this.isFieldEnabled(fieldName)) {
            // Determine the correct ID based on field name
            let fieldId: string;
            switch (fieldName) {
              case 'name':
                fieldId = this.nameOnCardId;
                break;
              case 'addressLine1':
                fieldId = this.addressLine1Id;
                break;
              case 'addressLine2':
                fieldId = this.addressLine2Id;
                break;
              case 'city':
                fieldId = this.cityId;
                break;
              case 'state':
                fieldId = this.stateId;
                break;
              case 'country':
                fieldId = this.countryId;
                break;
              case 'emailAddress':
                fieldId = this.emailAddressId;
                break;
              case 'phoneNumber':
                fieldId = this.phoneNumberId;
                break;
              default:
                fieldId = `${this.componentId}-${fieldName}`; // Fallback ID
            }

            return (
              <div class="odin-field-container" key={fieldName}>
                <label htmlFor={fieldId}>{this.getLabel(fieldName)}</label>
                <div id={fieldId} class="odin-input"></div>
              </div>
            );
          }
          return null; // Don't render if not enabled
        })}

        {/* Submit Area */}
        <div class="odin-submit-container">
          <button id={this.visibleSubmitButtonId} class="odin-submit-button" type="button" disabled={isButtonDisabled} onClick={this.handleVisibleSubmitClick}>
            {this.isLoading ? 'Loading...' : 'Pay'}
          </button>
          <button id={this.odinSubmitButtonId} type="button" style={{ display: 'none' }} aria-hidden="true"></button>
          <div class="odin-form-footer">Secured by ODIN Pay</div>
        </div>
      </div>
    );
  }
}
